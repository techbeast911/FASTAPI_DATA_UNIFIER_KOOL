from pydantic import BaseModel
from uuid import UUID,uuid4
from datetime import datetime
from typing import Optional



class BatteryCreate(BaseModel):

    customer_name : str
    product_sku : str
    product_serial_number : str
    field_technician : str
    condition : str
    receiver : str
    faulty_component : str
    remedy : str
    product_category_new_ref : str
    date_sent_out : Optional[datetime] = None 



# Schema for reading/representing a complete battery record (output from database)
class BatteryRecord(BaseModel):

    uid: UUID # Unique ID, generated by the database
    created_at: datetime # Timestamp when the record was created, generated by the database

    customer_name : str
    product_sku : str
    product_serial_number : str
    field_technician : str
    condition : str
    receiver : str
    faulty_component : str
    remedy : str
    product_category_new_ref : str
    date_sent_out : datetime # This will always have a value once saved


# Schema for updating existing battery records (all fields are optional)
class BatteryUpdate(BaseModel):
    customer_name : Optional[str] = None
    product_sku : Optional[str] = None
    product_serial_number : Optional[str] = None
    field_technician : Optional[str] = None
    condition : Optional[str] = None
    receiver : Optional[str] = None
    faulty_component : Optional[str] = None
    remedy : Optional[str] = None
    product_category_new_ref : Optional[str] = None
    date_sent_out : Optional[datetime] = None

